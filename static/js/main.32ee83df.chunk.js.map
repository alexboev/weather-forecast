{"version":3,"sources":["components/temperature.tsx","components/pager.tsx","components/weather_conditions_icon.tsx","utils/temperature.ts","utils/general.ts","utils/dates.ts","backend/backend.ts","store/store.ts","components/day_card.tsx","analysis.ts","utils/math.ts","components/days_list.tsx","components/day_details.tsx","components/settings.tsx","components/forecast.tsx","components/loading.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Celsius","Fahrenheit","Temperature","props","theme","useTheme","smallest","useMediaQuery","breakpoints","up","Grid","container","direction","justify","alignItems","item","RadioGroup","row","aria-label","name","value","isFahrenheit","onChange","event","onTemperatureModeChanged","target","FormControlLabel","control","Radio","label","Pager","spacing","style","visibility","enablePrevPage","undefined","fontSize","onClick","onPageChanged","page","enableNextPage","WeatherConditionsIcon","src","icon","celsiusFromKelvin","temperatureKelvin","fahrenheitFromKelvin","hasValue","hasText","trim","length","UnixDateTime","unixTimeStamp","timeZoneOffsetInHours","Error","timeZoneSuffix","this","Math","abs","DateTime","fromSeconds","setZone","currentHour","getDateTimeInZone","hour","toFormat","startOf","toSeconds","loadForecastFromServer","location","url","Promise","resolve","reject","fetch","method","then","response","json","cod","message","catch","error","getLoadingStatus","rootState","forecast","loading","status","getLoadingError","getDays","days","getQuery","query","getTimeZoneOffsetInHours","city","getCity","getCountry","country","loadForecast","createAsyncThunk","a","forecastSlice","createSlice","initialState","reducers","setQuery","state","action","payload","clearQuery","extraReducers","builder","addCase","pending","fulfilled","processedData","forecastTimeZoneHours","timezone","daysDictionary","Map","list","forEach","dayPartData","day","dayPartDateTime","dt","dayDate","getDateWithoutTime","getSeconds","has","get","date","temperatureParts","set","dayPartWeather","weather","push","dateTime","main","temp","weatherIcon","weatherId","id","weatherTitle","isDayTime","Array","from","values","processBackendData","rejected","useStyles","makeStyles","root","title","pos","marginBottom","DayCard","classes","temperatureCelsius","round","temperature","temperatureFahrenheit","useSelector","Card","elevation","selected","className","onSelect","CardHeader","Typography","variant","getDisplayText","CardContent","minWidth","color","gutterBottom","CardActions","Button","size","getPartsToUseInPrediction","useNightPartsInPredictions","filter","part","getDayTemperature","dayTemperatures","map","reduce","prev","current","getDayWeatherIcon","items","counts","count","mostAppearedCount","mostAppearedItem","getOneMostFrequent","DaysList","xs","sm","selectedCard","onSelectCard","DayDetails","data","timeTitle","getTimeDisplayText","marginTop","ResponsiveContainer","width","height","BarChart","barCategoryGap","XAxis","dataKey","YAxis","Bar","fill","Settings","FormControl","component","FormLabel","FormGroup","Switch","checked","onUseNightPartsInPredictionsChanged","discardDaysWithTooFiewPartsToAnalyze","onDiscardDaysWithTooFiewPartsToAnalyzeChanged","FormHelperText","flexGrow","paper","padding","textAlign","palette","text","secondary","Forecast","dispatch","useDispatch","mediumOrMore","useState","setIsFahrenheit","currentPage","setCurrentPage","setUseNightPartsInPredictions","setDiscardDaysWithTooFiewPartsToAnalyze","daysToShow","partsToUseInPrediction","getPage","skip","slice","selectedDay","currentPageData","setSelectedCard","find","d","md","marginLeft","marginRight","Link","actions","newIsFahrenheit","newPage","newCardDate","newValue","createStyles","margin","Loading","loadingStatus","loadingError","isIdle","isError","isLoading","queryInput","setQueryInput","queryInputRef","useRef","useEffect","focus","select","confirmTheQueryText","noValidate","autoComplete","TextField","inputRef","onKeyPress","key","preventDefault","CircularProgress","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","store","configureStore","reducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.32ee83df.chunk.js","sourcesContent":["import React from 'react';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport Radio from '@material-ui/core/Radio';\r\nimport RadioGroup from '@material-ui/core/RadioGroup';\r\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\r\nimport FormControl from '@material-ui/core/FormControl';\r\nimport FormLabel from '@material-ui/core/FormLabel';\r\nimport Box from '@material-ui/core/Box';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { useTheme } from '@material-ui/core/styles';\r\n\r\n// The available temperature options\r\nconst Celsius = \"Celsius\";\r\nconst Fahrenheit = \"Fahrenheit\";\r\n\r\n/** The temperature control UI */\r\nconst Temperature = (props: {\r\n    /** should we calculate temperatures as Fahrenheit */\r\n    isFahrenheit: boolean,\r\n    /** The mode has changed */\r\n    onTemperatureModeChanged: (isFahrenheit: boolean) => void\r\n}) => {\r\n    const theme = useTheme();\r\n    const smallest = !useMediaQuery(theme.breakpoints.up('sm'));\r\n\r\n    return (\r\n        <Grid container direction=\"row\" justify=\"space-around\" alignItems=\"center\">\r\n            <Grid item>\r\n                <RadioGroup \r\n                    row={!smallest} \r\n                        aria-label=\"temperature\" \r\n                        name=\"temperature\" \r\n                        value={props.isFahrenheit ? Fahrenheit : Celsius} \r\n                        onChange={event => {\r\n                            props.onTemperatureModeChanged(event.target.value == Fahrenheit);\r\n                        }}\r\n                        >\r\n                    <FormControlLabel value={Celsius} control={<Radio />} label=\"Celsius\" />\r\n                    <FormControlLabel value={Fahrenheit} control={<Radio />} label=\"Fahrenheit\" />\r\n                </RadioGroup>\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n};\r\n\r\nexport default Temperature;","import React from 'react';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport ChevronLeftIcon from '@material-ui/icons/ChevronLeft';\r\nimport ChevronRightIcon from '@material-ui/icons/ChevronRight';\r\nimport SvgIcon from '@material-ui/icons/ChevronLeft';\r\n\r\n/** The cards list selected data page control UI  */\r\nconst Pager = (props: {\r\n    /** Can we open the previous page */\r\n    enablePrevPage: boolean,\r\n    /** Can we open the next page */\r\n    enableNextPage: boolean,\r\n    /** The page is currently being displayed */\r\n    page: number,\r\n    /** The page has changed */\r\n    onPageChanged: (newPage: number) => void\r\n}) => {\r\n    return (\r\n        <Grid container spacing={1} direction=\"row\" justify=\"space-between\" alignItems=\"center\">\r\n            <Grid item>\r\n                <ChevronLeftIcon \r\n                    style={{\r\n                        visibility: props.enablePrevPage ? undefined : \"hidden\"\r\n                    }}\r\n                    fontSize=\"large\"\r\n                    onClick={() => {\r\n                        props.onPageChanged(props.page - 1);\r\n                    }}\r\n                    />\r\n            </Grid>\r\n            <Grid item>\r\n                <ChevronRightIcon \r\n                    style={{\r\n                        visibility: props.enableNextPage ? undefined : \"hidden\"\r\n                    }}\r\n                    fontSize=\"large\"\r\n                    onClick={() => {\r\n                        props.onPageChanged(props.page + 1);\r\n                    }}\r\n                    />\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n};\r\n\r\nexport default Pager;","import React from 'react';\r\n\r\n/** The weather icon */\r\nconst WeatherConditionsIcon = (props: {\r\n    /** the icon name */\r\n    icon: string | null\r\n}) => {\r\n\r\n    return (\r\n        <img src={`http://openweathermap.org/img/wn/${props.icon}@2x.png`}></img>\r\n    );\r\n};\r\n\r\nexport default WeatherConditionsIcon;","export function celsiusFromKelvin(temperatureKelvin: number): number {\r\n    // Celsius = (Kelvin – 273.15)\r\n    return temperatureKelvin - 273.15;\r\n}\r\n\r\nexport function fahrenheitFromKelvin(temperatureKelvin: number): number {\r\n    // Fahrenheit = Celsius × 9/5 + 32\r\n    return celsiusFromKelvin(temperatureKelvin) * 9/5 + 32;\r\n}","export function hasValue(value: any): boolean{\r\n    return value != undefined && value != null;\r\n}\r\n\r\nexport function hasText(value: string): boolean {\r\n    return hasValue(value) && value.trim().length > 0;\r\n}\r\n\r\nexport function getOneMostFrequent<TValue>(items: TValue[]): TValue | null {\r\n    let counts = new Map<TValue, number>();\r\n    items.forEach(item => {\r\n        let count: number = <number>counts.get(<TValue>item);\r\n        if (!hasValue(count)){\r\n           count = 0;\r\n        }\r\n\r\n        count++;\r\n        counts.set(<TValue>item, count);\r\n    });\r\n\r\n    let mostAppearedCount = 0;\r\n    let mostAppearedItem: TValue | null = null;\r\n    counts.forEach((count, item) => {\r\n        if (count > mostAppearedCount){\r\n            mostAppearedItem = item;\r\n            mostAppearedCount = count;\r\n        }\r\n    });\r\n\r\n    return mostAppearedItem;\r\n}","import { DateTime } from \"luxon\";\r\nimport { hasValue } from \"./general\";\r\n\r\n// The errors whick protect our wrapper from uninitialized values\r\nexport const ERROR_TIMESTAMP_IS_NULL = \"Unix timestamp is requred but is null or undefined\";\r\nexport const ERROR_TIMEZONE_IS_NULL = \"Timezone is requred but is null or undefined\";\r\n\r\n/*\r\n    The task requires that we show the average day's temperature. But the data arrives in about 8 slices \r\n    so we have to calculate an average value. The issue here is that it is reasonable to\r\n    assume that the user wants to know the DAY TIME TEMPERATURE and it's likely that he is not \r\n    interested in night temperatures. If we account for the night temperatures the average value will \r\n    be generally colder due to the colder air at night. So we have implemented the ability to ignore \r\n    night temperatures during the calculation if the user wants to do so. But how can we determine is it\r\n    a day or night? We have to do some guess here. Let's use some reasonable restrictions here base on\r\n    our experience.\r\n*/\r\nexport const DAYTIME_HOUR_START = 7;\r\nexport const DAYTIME_HOUR_END = 21;\r\n\r\n/** A datetime operations wrapper to simplify app's logic*/\r\nexport class UnixDateTime {\r\n    constructor(\r\n        private unixTimeStamp: number,\r\n        private timeZoneOffsetInHours: number\r\n        ){\r\n\r\n        if (!hasValue(unixTimeStamp)){\r\n            throw Error(ERROR_TIMESTAMP_IS_NULL);\r\n        }\r\n\r\n        if (!hasValue(timeZoneOffsetInHours)){\r\n            throw Error(ERROR_TIMEZONE_IS_NULL);\r\n        }\r\n    }\r\n\r\n    /** get the date object with a specific timezone */\r\n    private getDateTimeInZone(): DateTime {\r\n        let timeZoneSuffix = \"+0\";\r\n        if (this.timeZoneOffsetInHours > 0){\r\n            timeZoneSuffix = \"+\" + Math.abs(this.timeZoneOffsetInHours);\r\n        }\r\n        else if (this.timeZoneOffsetInHours < 0){\r\n            timeZoneSuffix = \"-\" + Math.abs(this.timeZoneOffsetInHours);\r\n        }\r\n\r\n        return DateTime\r\n        .fromSeconds(this.unixTimeStamp)\r\n        .setZone(`UTC${timeZoneSuffix}`);\r\n    }\r\n\r\n    /** Is our datetime represents day time or night ? */\r\n    isDayTime(): boolean\r\n    {\r\n        // For reasoning please see the comment above (regarding the DAYTIME_HOUR_START and DAYTIME_HOUR_END constants)\r\n        let dateTime = this.getDateTimeInZone();\r\n        let currentHour = dateTime.hour;\r\n        return currentHour >= DAYTIME_HOUR_START && currentHour < DAYTIME_HOUR_END;\r\n    }\r\n\r\n    /** The user-friendly date label text */\r\n    getDisplayText(): string{\r\n        return this.getDateTimeInZone().toFormat(\"dd MMM yy\");\r\n    }\r\n\r\n    /** The user-friendly time label text */\r\n    getTimeDisplayText(): string{\r\n        return this.getDateTimeInZone().toFormat(\"HH:mm\");\r\n    }\r\n\r\n    /** Return the date component of datetime which is helpful to determine the similarity of dates */\r\n    getDateWithoutTime(): UnixDateTime {\r\n        let dateTime = this.getDateTimeInZone();\r\n        let date = dateTime.startOf(\"day\");\r\n        let dateSeconds = date.toSeconds();\r\n        return new UnixDateTime(dateSeconds, this.timeZoneOffsetInHours);\r\n    }\r\n\r\n    /** return the date in the form of seconds to help to store dates, compare them etc. */\r\n    getSeconds(): number {\r\n        return this.getDateTimeInZone().toSeconds();\r\n    }\r\n\r\n    \r\n}\r\n","import { hasText } from \"../utils/general\";\r\n\r\nconst apiKey = \"75f972b80e26f14fe6c920aa6a85ad57\";\r\nconst limitBy = 40;\r\n\r\n\r\nexport interface IForecastResponse_DayPart {\r\n    dt: number,\r\n    main: {\r\n        temp: number,\r\n        feels_like: number\r\n    },\r\n    weather: Array<{\r\n        id: number,\r\n        main: string,\r\n        description: string,\r\n        icon: string\r\n    }>\r\n}\r\n\r\n/** Forecast data. See description here - https://openweathermap.org/forecast5#JSON */\r\nexport interface IForecastResponse {\r\n    cod: string;\r\n    message: string;\r\n    cnt: number;\r\n    list: IForecastResponse_DayPart[];\r\n    city: {\r\n        name: string,\r\n        country: string,\r\n        timezone: number;\r\n    }\r\n}\r\n\r\nexport function loadForecastFromServer(location: string): Promise<IForecastResponse> {\r\n    const url = `http://api.openweathermap.org/data/2.5/forecast?q=${location}&APPID=${apiKey}&cnt=${limitBy}`;\r\n    return new Promise<IForecastResponse>((resolve, reject) => {\r\n        fetch(url, {\r\n            method: 'GET',\r\n            // headers: {\r\n            //     'Accept': 'application/json',\r\n            //     'Content-Type': 'application/json'\r\n            // }\r\n        })\r\n            .then(response => {\r\n                response.json().then((response: IForecastResponse) => {\r\n                    if (response.cod == \"200\"){\r\n                        resolve(response);\r\n                    }\r\n                    else {\r\n                        if (hasText(response.message)){\r\n                            reject(response.message);\r\n                        }\r\n                        else {\r\n                            reject(\"Unknown error.\");\r\n                        }\r\n                    }\r\n                }).catch((error) => {\r\n                    reject(error);\r\n                });\r\n            }).catch(error => {\r\n                reject(error);\r\n            })\r\n    });\r\n}","import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport { IForecastResponse, loadForecastFromServer } from '../backend/backend';\r\nimport { UnixDateTime } from '../utils/dates';\r\n\r\n//#region selectors\r\n\r\nexport const getLoadingStatus = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return forecastState.loading.status;\r\n};\r\n\r\nexport const getLoadingError = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return forecastState.loading.error;\r\n};\r\n\r\n\r\n\r\nexport const getDays = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return forecastState.days;\r\n};\r\n\r\nexport const getQuery: (rootState: any) => string = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return <string>forecastState.query;\r\n};\r\n\r\nexport const getTimeZoneOffsetInHours: (rootState: any) => number = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return <number>forecastState.city.timeZoneOffsetInHours;\r\n};\r\n\r\nexport const getCity: (rootState: any) => string | null = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return forecastState.city.name;\r\n};\r\n\r\nexport const getCountry: (rootState: any) => string | null = (rootState: any)  => {\r\n    let forecastState: IState = rootState.forecast;\r\n    return forecastState.city.country;\r\n};\r\n\r\n//#endregion \r\n\r\n//#region thunks\r\n/** the loading of the forecast data from the API */\r\nexport const loadForecast = createAsyncThunk('loadForecast', async (\r\n    /** the location query text */\r\n    location: string\r\n    ) => {\r\n    const response = await loadForecastFromServer(location);\r\n    return response;\r\n});\r\n//#endregion\r\n\r\nexport interface IDayTemperaturePart {\r\n    dateTime: number;\r\n    isDayTime: boolean;\r\n    temperatureKelvin: number;\r\n    weatherIcon: string | null;\r\n    weatherId: number | null;\r\n    weatherTitle: string | null;\r\n}\r\n\r\nexport interface IDay {\r\n    date: number;\r\n    temperatureParts: IDayTemperaturePart[];\r\n}\r\n\r\nfunction processBackendData(response: IForecastResponse): {\r\n    /** all the weather data grouped by dates */\r\n    days: IDay[],\r\n    /** the location info */\r\n    city: {\r\n        name: string,\r\n        country: string,\r\n        timeZoneOffsetInHours: number\r\n    }\r\n} {\r\n    /*  The API returns dates in UTC format with the separate timezone info \r\n        for the requested location. The timezone shift arrives to us in seconds.\r\n        We use the Luxon dates management library which operates with hours. So\r\n        we need to convert.\r\n    */\r\n    const secondsInHour = 3600;\r\n    let forecastTimeZoneHours = response.city.timezone / secondsInHour;\r\n\r\n    /*  The data arrives in 3-hour slices but we need to show the average daily forecast.\r\n        so we need to group data by days.\r\n    */\r\n    let daysDictionary = new Map<\r\n        number, // date in seconds. It's easier to compare such dates and to we can store them in Redux.\r\n        IDay // All the data collected for the single day\r\n        >();\r\n\r\n    // let's process the data slices\r\n    response.list.forEach(dayPartData => {\r\n        // let's extract the date for the slice.\r\n        let dayPartDateTime = new UnixDateTime(dayPartData.dt, forecastTimeZoneHours);\r\n\r\n        // in order to compare dates for the different slices we need to discard the time info\r\n        let normalizedDate = dayPartDateTime.getDateWithoutTime();\r\n        let dayDate = normalizedDate.getSeconds();\r\n\r\n        /*  let's prepare the data \"container\" for the day of our slice - it's where we will store \r\n            all the slices for the same day. We use the existing container or create the new one if \r\n            it doesn't exists.\r\n        */\r\n        let day: IDay;\r\n        if (daysDictionary.has(dayDate)){\r\n            // if we have already processed some data for the same day let's append.\r\n            day = <IDay>daysDictionary.get(dayDate);\r\n        } else {\r\n            // if it's the first slice for the date let's create the container\r\n            day = {\r\n                date: dayDate, // the date of our grouped slices\r\n                temperatureParts: [], // the slices' data\r\n            };\r\n            daysDictionary.set(dayDate, day);\r\n        }\r\n\r\n        // let's create an alias for the weather info of the slice for the sake of code simplicity\r\n        let dayPartWeather = dayPartData.weather[0];\r\n\r\n        // the slice contains a lot of various data. Let's collect what we need.\r\n        day.temperatureParts.push({\r\n            dateTime: dayPartDateTime.getSeconds(), // the date\r\n            temperatureKelvin: dayPartData.main.temp, // the temperature\r\n            weatherIcon: dayPartWeather.icon, // the weather icon\r\n            weatherId: dayPartWeather.id, // the weather category\r\n            weatherTitle: dayPartWeather.main, // the weather description\r\n            isDayTime: dayPartDateTime.isDayTime() // is the slice from the \"day time\" part of the whole day\r\n        });\r\n    });\r\n\r\n    // let's return the collected data\r\n    let days = Array.from(daysDictionary.values());\r\n    return {\r\n        days, // the assembled days\r\n        city: { // the location we have recieved forecast for\r\n            name: response.city.name, // the name of the city\r\n            country: response.city.country, // the country \r\n            timeZoneOffsetInHours: forecastTimeZoneHours // the timezone\r\n        }\r\n    };\r\n}\r\n\r\n//#region State\r\ninterface IState {\r\n    loading: {\r\n        status: 'idle' | 'loading' | 'succeeded' | 'failed',\r\n        error: string | null\r\n    },\r\n    days: IDay[],\r\n    city: {\r\n        timeZoneOffsetInHours: number | null,\r\n        name: string | null,\r\n        country: string | null\r\n    },\r\n    query: string | null\r\n}\r\n\r\nvar initialState: IState = {\r\n    loading: {\r\n        status: 'idle',\r\n        error: null\r\n    },\r\n    days: [],\r\n    city: {\r\n        country: null,\r\n        name: null,\r\n        timeZoneOffsetInHours: null\r\n    },\r\n    query: null\r\n};\r\n\r\n//#endregion\r\n\r\n//#region Slice\r\nexport const forecastSlice = createSlice({\r\n    name: 'forecast',\r\n    initialState: initialState,\r\n    reducers: {\r\n        setQuery: (state, action: {\r\n            payload: {\r\n                query: string\r\n            }\r\n        }) => {\r\n            state.query = action.payload.query;\r\n            state.loading.status = 'idle';\r\n            state.loading.error = null;\r\n        },\r\n        clearQuery: (state, action) => {\r\n            state.query = null;\r\n            state.loading.status = 'idle';\r\n            state.loading.error = null;\r\n        }\r\n    },\r\n    extraReducers: builder => {\r\n//#region forecast loading thunk processing\r\n        // we are waiting for the API response\r\n        builder.addCase(loadForecast.pending, (state: IState, action) => {\r\n            state.loading.status = 'loading';\r\n        });\r\n        // we have successfully recieved the data from the API\r\n        builder.addCase(loadForecast.fulfilled, (state, action) => {\r\n            state.loading.status = 'succeeded';\r\n            let processedData = processBackendData(action.payload);\r\n            state.days = processedData.days;\r\n            state.city.name = processedData.city.name;\r\n            state.city.country = processedData.city.country;\r\n            state.city.timeZoneOffsetInHours = processedData.city.timeZoneOffsetInHours;\r\n        });\r\n        // we have recieved the error instead of the data from the API\r\n        builder.addCase(loadForecast.rejected, (state, action) => {\r\n            state.loading.status = 'failed';\r\n            state.loading.error = <string>action.error.message;\r\n        })\r\n//#endregion\r\n      }\r\n});\r\n\r\n//#endregion","import React from 'react';\r\nimport { makeStyles, useTheme } from '@material-ui/core/styles';\r\nimport Card from '@material-ui/core/Card';\r\nimport CardActions from '@material-ui/core/CardActions';\r\nimport CardContent from '@material-ui/core/CardContent';\r\nimport Button from '@material-ui/core/Button';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport WeatherConditionsIcon from './weather_conditions_icon';\r\nimport { celsiusFromKelvin, fahrenheitFromKelvin } from '../utils/temperature';\r\nimport { UnixDateTime } from '../utils/dates';\r\nimport { useSelector } from 'react-redux';\r\nimport { getTimeZoneOffsetInHours } from '../store/store';\r\nimport { CardHeader, Grid } from '@material-ui/core';\r\n\r\nconst useStyles = makeStyles({\r\n    root: {\r\n      //minWidth: 275,\r\n    },\r\n    title: {\r\n      fontSize: 14,\r\n    },\r\n    pos: {\r\n      marginBottom: 12,\r\n    },\r\n  });\r\n\r\n  /** The single day weather info card */\r\nconst DayCard = (props: {\r\n    /** the average day temperature */\r\n    temperature: number,\r\n    /** the date we show the weather for */\r\n    date: number,\r\n    /** should we show the temperature as Fahrenheit */\r\n    isFahrenheit: boolean,\r\n    /** The weather icon for the day */\r\n    icon: string | null,\r\n    /** Has user clicked on our card to select this day to show the details */\r\n    selected: boolean,\r\n    /** The user has clicked on our day to select this day to show the details */\r\n    onSelect: () => void\r\n}) => {\r\n    const classes = useStyles();\r\n\r\n    const theme = useTheme();\r\n\r\n    // let's calculate both the temperature modes\r\n    const temperatureCelsius = Math.round(celsiusFromKelvin(props.temperature));\r\n    const temperatureFahrenheit = Math.round(fahrenheitFromKelvin(props.temperature));\r\n\r\n    // let's get the current date with resprect to its timezone\r\n    const timeZoneOffsetInHours = useSelector(getTimeZoneOffsetInHours);\r\n    const date = new UnixDateTime(props.date, timeZoneOffsetInHours);\r\n\r\n    return (\r\n        <Card elevation={props.selected ? 20 : 5} className={classes.root} onClick={() => {\r\n          props.onSelect();\r\n        }}>\r\n          <CardHeader title={\r\n          <Typography \r\n            variant=\"h5\"\r\n            >\r\n              {date.getDisplayText()}\r\n            </Typography>\r\n        }>\r\n          \r\n        </CardHeader>\r\n      <CardContent>\r\n        \r\n        <Grid container justify=\"center\" alignItems=\"center\">\r\n            <Grid item>\r\n              <Typography style={{\r\n                minWidth: `${130}px`\r\n              }} variant=\"h2\">\r\n                {props.isFahrenheit && <>{temperatureFahrenheit}&#8457;</>}\r\n                {!props.isFahrenheit && <>{temperatureCelsius}&#8451;</>}\r\n              </Typography>\r\n            </Grid>\r\n            <Grid item>\r\n              <WeatherConditionsIcon icon={props.icon}/>\r\n            </Grid>\r\n        </Grid>\r\n        \r\n        <Typography className={classes.title} color=\"textSecondary\" gutterBottom>\r\n          \r\n        </Typography>\r\n        \r\n      </CardContent>\r\n      <CardActions>\r\n        <Button size=\"small\" color=\"primary\">Details</Button>\r\n      </CardActions>\r\n    </Card>\r\n    );\r\n};\r\n\r\nexport default DayCard;","import { IDay, IDayTemperaturePart } from \"./store/store\";\r\nimport { getOneMostFrequent, hasValue } from \"./utils/general\";\r\nimport { average } from \"./utils/math\";\r\n\r\n/** returns the slices of the day temperature we'd like to use in our calculations */\r\nexport function getPartsToUseInPrediction(\r\n    day: IDay, // the collected day data\r\n    useNightPartsInPredictions: boolean // should we consider night temperatures\r\n    \r\n    ): IDayTemperaturePart[]{\r\n    return useNightPartsInPredictions \r\n            ? day.temperatureParts\r\n            : day.temperatureParts.filter(part => part.isDayTime);\r\n}\r\n\r\n/** Calculates the average day temperature */\r\nexport function getDayTemperature(\r\n    day: IDay, // the collected day data \r\n    useNightPartsInPredictions: boolean  // should we consider night temperatures\r\n    ): number {\r\n    let partsToUseInPrediction = getPartsToUseInPrediction(day, useNightPartsInPredictions);\r\n    let dayTemperatures = partsToUseInPrediction.map(part => part.temperatureKelvin);\r\n    return average(dayTemperatures);\r\n}\r\n\r\n/** Calculate the average day weather */\r\nexport function getDayWeatherIcon(\r\n    day: IDay, // the collected day data\r\n    useNightPartsInPredictions: boolean // should we consider night temperatures\r\n    ): string | null {\r\n    let partsToUseInPrediction = getPartsToUseInPrediction(day, useNightPartsInPredictions);\r\n    let dayWeatherIcons = partsToUseInPrediction.map(part => part.weatherIcon);\r\n\r\n    /*  we can't get \"average\" weather icon so we do the most reasonable thing we can - we get the most \r\n        frequently appearing icon\r\n    */\r\n    let mostFrequentIcon = getOneMostFrequent(dayWeatherIcons);\r\n\r\n    return mostFrequentIcon;\r\n}","export function average(values: number[]): number {\r\n    let sum = values.reduce((prev, current) => prev + current, 0);\r\n    return sum / values.length;\r\n}","import React from 'react';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport DayCard from './day_card';\r\nimport { useSelector } from 'react-redux';\r\nimport { getDays, IDay, IDayTemperaturePart } from '../store/store';\r\nimport { average } from '../utils/math';\r\nimport { getDayTemperature, getDayWeatherIcon, getPartsToUseInPrediction } from '../analysis';\r\n\r\n/** The cards list for days */\r\nconst DaysList = (props: {\r\n    /** should we show the temperatures as Fahrenheit */\r\n    isFahrenheit: boolean,\r\n    /** should we consider the night temperatures when calculating the average day temps */\r\n    useNightPartsInPredictions: boolean,\r\n    /** the all days collected data */\r\n    days: IDay[],\r\n    /** the day card user has selected to show the day details in chart */\r\n    selectedCard: number | null,\r\n    /** user has selected the day card to show the day details in chart */\r\n    onSelectCard: (date: number) => void\r\n}) => {\r\n    return (\r\n        <Grid container spacing={2} direction=\"row\" justify=\"center\" alignItems=\"center\">\r\n            {\r\n                props.days.map(day => (\r\n                    <Grid key={day.date} item xs={12} sm={4}>\r\n                        <DayCard\r\n                            selected={day.date === props.selectedCard}\r\n                            onSelect={() =>{\r\n                                props.onSelectCard(day.date)\r\n                            }}\r\n                            isFahrenheit={props.isFahrenheit} \r\n                            temperature={getDayTemperature(day, props.useNightPartsInPredictions)} \r\n                            date={day.date}\r\n                            icon={getDayWeatherIcon(day, props.useNightPartsInPredictions)}\r\n                            />\r\n                    </Grid>\r\n                ))\r\n            }\r\n        </Grid>\r\n    );\r\n};\r\n\r\nexport default DaysList;","import React from 'react';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport { BarChart, CartesianGrid, XAxis, YAxis, Tooltip, Legend, Bar, ResponsiveContainer } from 'recharts';\r\nimport { getTimeZoneOffsetInHours, IDay } from '../store/store';\r\nimport { UnixDateTime } from '../utils/dates';\r\nimport { celsiusFromKelvin, fahrenheitFromKelvin } from '../utils/temperature';\r\nimport { useSelector } from 'react-redux';\r\nimport { Container, Typography } from '@material-ui/core';\r\nimport { hasValue } from '../utils/general';\r\n\r\n/** The detailed stats for the single day */\r\nconst DayDetails = (props: {\r\n    /** The day we should show stats for */\r\n    day: IDay | undefined,\r\n    /** Should we show the temperatures as Fahrenheit */\r\n    isFahrenheit: boolean,\r\n}) => {\r\n    // let's find out the location's timezone\r\n    const timeZoneOffsetInHours = useSelector(getTimeZoneOffsetInHours);\r\n\r\n    // let's prepare the data for the temperature bars of our chart\r\n    let data: any[] = [];\r\n\r\n    // if the user has selected the day\r\n    if (props.day){\r\n        // prepare one chart bar for each temperature slices of the day\r\n        props.day.temperatureParts.forEach(part => {\r\n            // adjust the slice time title\r\n            let timeTitle = new UnixDateTime(part.dateTime, timeZoneOffsetInHours).getTimeDisplayText();\r\n            \r\n            // calculate both possible temperature modes\r\n            const temperatureCelsius = Math.round(celsiusFromKelvin(part.temperatureKelvin));\r\n            const temperatureFahrenheit = Math.round(fahrenheitFromKelvin(part.temperatureKelvin));\r\n\r\n            // prepare the slice data according to the chart bindings\r\n            let item = {\r\n                /** the time of the slice */\r\n                name: timeTitle,\r\n                /** the temperature */\r\n                temp: props.isFahrenheit ? temperatureFahrenheit : temperatureCelsius\r\n            };\r\n\r\n            data.push(item);\r\n        });\r\n    }\r\n\r\n    return (\r\n        <>\r\n        <Grid container justify=\"center\" alignItems=\"center\" style={{\r\n            marginTop: \"30px\"\r\n        }}>\r\n            <Grid item>\r\n            <Typography variant=\"h5\">{\r\n                props.day \r\n                ? `Temperatures for ${new UnixDateTime(props.day.date, timeZoneOffsetInHours).getDisplayText()}` \r\n                : \"Select the day to see the details\"\r\n                }\r\n            </Typography>\r\n            </Grid>\r\n        </Grid>    \r\n            <ResponsiveContainer width=\"100%\" height={300}>\r\n                    <BarChart width={730} height={250} data={data} barCategoryGap={5}>\r\n                        \r\n                        <XAxis dataKey=\"name\" />\r\n                        <YAxis />\r\n                        <Bar label dataKey=\"temp\" fill=\"#8884d8\" />\r\n                        \r\n                    </BarChart>\r\n                </ResponsiveContainer>\r\n        </>\r\n    );\r\n};\r\n\r\nexport default DayDetails;","import { FormControl, FormLabel, FormGroup, FormControlLabel, Switch, FormHelperText } from '@material-ui/core';\r\nimport React from 'react';\r\n\r\n/** The settings control UI */\r\nconst Settings = (props: {\r\n    /** Should we consider the night temperatures */\r\n    useNightPartsInPredictions: boolean,\r\n    onUseNightPartsInPredictionsChanged: (newValue: boolean) => void,\r\n    /** Should we consider the days with too few data to analyze */\r\n    discardDaysWithTooFiewPartsToAnalyze: boolean,\r\n    onDiscardDaysWithTooFiewPartsToAnalyzeChanged: (newValue: boolean) => void,\r\n}) => {\r\n    return <FormControl component=\"fieldset\">\r\n    <FormLabel component=\"legend\">Settings</FormLabel>\r\n    <FormGroup>\r\n      <FormControlLabel\r\n        control={<Switch \r\n            checked={props.useNightPartsInPredictions} \r\n            onChange={(event) => {\r\n                props.onUseNightPartsInPredictionsChanged(event.target.checked);\r\n            }}\r\n             />}\r\n        label=\"Consider night hours when calculating the day weather\"\r\n      />\r\n      <FormControlLabel\r\n        control={<Switch \r\n            checked={props.discardDaysWithTooFiewPartsToAnalyze} \r\n            onChange={(event) => {\r\n                props.onDiscardDaysWithTooFiewPartsToAnalyzeChanged(event.target.checked);\r\n            }}\r\n             />}\r\n        label=\"Discard days with too fiew parts to analyze\"\r\n      />\r\n    </FormGroup>\r\n    <FormHelperText>Change these settings to fine tune predictions</FormHelperText>\r\n  </FormControl>;\r\n};\r\n\r\nexport default Settings;","import React, { useState } from 'react';\r\nimport logo from './logo.svg';\r\nimport './../App.css';\r\nimport Button from '@material-ui/core/Button';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport Temperature from './temperature';\r\nimport Pager from './pager';\r\nimport DaysList from './days_list';\r\nimport DayDetails from './day_details';\r\nimport { forecastSlice, getCity, getCountry, getDays, IDay } from '../store/store';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { getPartsToUseInPrediction } from '../analysis';\r\nimport Settings from './settings';\r\nimport { Container, Link, Typography } from '@material-ui/core';\r\nimport { Box } from '@material-ui/core';\r\n\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n  },\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    textAlign: 'center',\r\n    color: theme.palette.text.secondary,\r\n  },\r\n}));\r\n\r\n/** the loaded weather screen */\r\nconst Forecast = (props: {\r\n\r\n}) => {\r\n    const dispatch = useDispatch();\r\n    const classes = useStyles();\r\n\r\n    const theme = useTheme();\r\n\r\n    // we need to detect the MD breakpoint to adjust some layout details programmatically\r\n    const mediumOrMore = useMediaQuery(theme.breakpoints.up('md'));\r\n\r\n    // The state for the temperature mode selection\r\n    const [isFahrenheit, setIsFahrenheit] = useState(true);\r\n\r\n    // According to tech requirements we page data by 3\r\n    const pageSize = 3;\r\n\r\n    // Currently selected page\r\n    const [currentPage, setCurrentPage] = useState(0);\r\n\r\n    // All the data for the days\r\n    const days: IDay[] = useSelector(getDays);\r\n\r\n    // Should we consider night hours during our calculations\r\n    const [useNightPartsInPredictions, setUseNightPartsInPredictions] = useState(false);\r\n\r\n    // Should we ignore the days with too few data to analyze\r\n    const [discardDaysWithTooFiewPartsToAnalyze, setDiscardDaysWithTooFiewPartsToAnalyze] = useState(true);\r\n\r\n    // The API returns the detected location - we should show it\r\n    const city = useSelector(getCity);\r\n    const country = useSelector(getCountry);\r\n\r\n    // let's get the days we need to display\r\n    const daysToShow = days.filter(day => {\r\n        // get the days according to the settings\r\n        let partsToUseInPrediction = getPartsToUseInPrediction(day, useNightPartsInPredictions);\r\n\r\n        return discardDaysWithTooFiewPartsToAnalyze\r\n            ? partsToUseInPrediction.length >= 4 // The reasonable amount is the half of the possible stats\r\n            : partsToUseInPrediction.length >= 1; // The minimum is 1 slice of the temp. There can be zero slices if we ingore nights and all the slices are night slices\r\n    });\r\n\r\n    // getting the page of days data\r\n    function getPage(page: number): IDay[] {\r\n        const skip = page * pageSize;\r\n        const take = pageSize;\r\n        return daysToShow.slice(skip, skip + take);\r\n    }\r\n\r\n    // let's get the current page to show it\r\n    const currentPageData = getPage(currentPage);\r\n\r\n    // let's get the next page to be able to determine should we allow to move next\r\n    const nextPageData = getPage(currentPage + 1);\r\n\r\n    // can we move prev or next\r\n    const enablePrevPage = currentPage > 0;\r\n    const enableNextPage = nextPageData.length > 0;\r\n\r\n    // the selected card (the one we should show the details for)\r\n    const [selectedCard, setSelectedCard] = useState<number | null>(null);\r\n\r\n    // let's get the selected day\r\n    let selectedDay: IDay | undefined;\r\n    if (selectedCard) {\r\n        selectedDay = days.find(d => d.date === selectedCard);\r\n    } else {\r\n        selectedDay = undefined;\r\n    }\r\n\r\n    return (\r\n        <div className={classes.root} style={{\r\n            width: mediumOrMore ? `${theme.breakpoints.values.md}px` : \"100%\",\r\n            marginLeft: \"auto\",\r\n            marginRight: \"auto\"\r\n        }}>\r\n\r\n            <Grid container spacing={1} style={{ padding: \"20px\" }}>\r\n                <Grid item xs={12}>\r\n                    <Grid container justify=\"center\" alignItems=\"center\" direction=\"column\">\r\n                        <Grid item>\r\n                            <Typography variant=\"h4\">\r\n                                The weather for {`${city}, ${country}`}\r\n                            </Typography>\r\n                        </Grid>\r\n                        <Grid item>\r\n                            <Link onClick={() => {\r\n                                dispatch(forecastSlice.actions.clearQuery(null));\r\n                            }}>change</Link>\r\n                        </Grid>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid item xs={12}>\r\n                    <Temperature\r\n                        isFahrenheit={isFahrenheit}\r\n                        onTemperatureModeChanged={newIsFahrenheit => {\r\n                            setIsFahrenheit(newIsFahrenheit);\r\n                        }}\r\n                    />\r\n                </Grid>\r\n                <Grid item xs={12}>\r\n                    <Pager\r\n                        enablePrevPage={enablePrevPage}\r\n                        enableNextPage={enableNextPage}\r\n                        page={currentPage}\r\n                        onPageChanged={newPage => {\r\n                            setCurrentPage(newPage);\r\n                        }}\r\n                    />\r\n                </Grid>\r\n                <Grid item xs={12}>\r\n                    <DaysList\r\n                        useNightPartsInPredictions={useNightPartsInPredictions}\r\n                        selectedCard={selectedCard}\r\n                        onSelectCard={newCardDate => {\r\n                            setSelectedCard(newCardDate);\r\n                        }}\r\n                        isFahrenheit={isFahrenheit}\r\n                        days={currentPageData}\r\n                    />\r\n                </Grid>\r\n                <Grid item xs={12}>\r\n                    <DayDetails\r\n                        day={selectedDay}\r\n                        isFahrenheit={isFahrenheit}\r\n                    />\r\n                </Grid>\r\n                <Grid item xs={12}>\r\n                    <Grid container justify=\"center\">\r\n                        <Grid item>\r\n                            <Settings\r\n                                useNightPartsInPredictions={useNightPartsInPredictions}\r\n                                onUseNightPartsInPredictionsChanged={newValue => {\r\n                                    setUseNightPartsInPredictions(newValue);\r\n                                    setCurrentPage(0);\r\n                                    setSelectedCard(null);\r\n                                }}\r\n                                discardDaysWithTooFiewPartsToAnalyze={discardDaysWithTooFiewPartsToAnalyze}\r\n                                onDiscardDaysWithTooFiewPartsToAnalyzeChanged={newValue => {\r\n                                    setDiscardDaysWithTooFiewPartsToAnalyze(newValue);\r\n                                    setCurrentPage(0);\r\n                                    setSelectedCard(null);\r\n                                }}\r\n                            />\r\n                        </Grid>\r\n                    </Grid>\r\n\r\n                </Grid>\r\n            </Grid>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Forecast;\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport Grid from '@material-ui/core/Grid';\r\nimport { useDispatch, useSelector } from 'react-redux';\r\nimport { forecastSlice, getLoadingError, getLoadingStatus, getQuery, loadForecast } from '../store/store';\r\nimport { makeStyles, Theme, createStyles, TextField, Button, Box, Typography, CircularProgress } from '@material-ui/core';\r\nimport { hasText } from '../utils/general';\r\n\r\nconst useStyles = makeStyles((theme: Theme) =>\r\n  createStyles({\r\n    root: {\r\n      '& > *': {\r\n        margin: theme.spacing(1),\r\n        width: '25ch',\r\n      },\r\n    },\r\n  }),\r\n);\r\n\r\nconst Loading = (props: {\r\n\r\n}) => {\r\n    const dispatch = useDispatch();\r\n\r\n    /** The status of the data loading */\r\n    const loadingStatus = useSelector(getLoadingStatus);\r\n\r\n    /** The error message if the query has failed */\r\n    const loadingError = useSelector(getLoadingError);\r\n\r\n    // The tests for different query states\r\n    const isIdle = loadingStatus === \"idle\";\r\n    const isError = loadingStatus === \"failed\";\r\n    const isLoading = loadingStatus === \"loading\";\r\n    const isLoaded = loadingStatus === \"succeeded\";\r\n\r\n    const classes = useStyles();\r\n\r\n    /** The confirmed query text */\r\n    const query = useSelector(getQuery);\r\n\r\n    /** The text typed in the search text field */\r\n    const [queryInput, setQueryInput] = useState<string>(\"Munich\"); // we use Munich as the demo city\r\n\r\n    const queryInputRef: any = useRef(null);\r\n\r\n    // Let's set the focus on text and select it to help user to easely change it\r\n    useEffect(() => {\r\n        if (queryInputRef.current){\r\n            queryInputRef.current.focus();\r\n            queryInputRef.current.select();\r\n        }\r\n    }, []);\r\n    \r\n    useEffect(() => {\r\n        // if there is a query text which was confirmed we should try to load the data\r\n        if (isIdle && hasText(query)) {\r\n            dispatch(loadForecast(query))\r\n        }\r\n    }, [loadingStatus, dispatch, query]);\r\n\r\n    /** confirms the entered text as query input */\r\n    const confirmTheQueryText = () => {\r\n        dispatch(forecastSlice.actions.setQuery({\r\n            query: queryInput\r\n        }));\r\n    };\r\n\r\n    return (\r\n        <Grid container spacing={2} direction=\"column\" justify=\"center\" alignItems=\"center\">\r\n            <Grid item xs={12}>\r\n                {isError && <></>}\r\n                <form className={classes.root} noValidate autoComplete=\"off\">\r\n                    <TextField \r\n                        inputRef={queryInputRef}\r\n                        label=\"Location\" \r\n                        variant=\"outlined\" \r\n                        size=\"small\"\r\n                        value={queryInput}\r\n                        onChange={event => {\r\n                            setQueryInput(event.target.value);\r\n                        }}\r\n                        onKeyPress={event =>{\r\n                            // We should search when the user hits the Enter key\r\n                            if (event.key == \"Enter\"){\r\n                                event.preventDefault();\r\n\r\n                                // let's confirm the search text so we have access to it while loading\r\n                                confirmTheQueryText();\r\n                            }\r\n                        }}\r\n                        />\r\n                        <Button \r\n                            variant=\"contained\"\r\n                            \r\n                            color=\"primary\"\r\n                            onClick={() =>{\r\n                                confirmTheQueryText();\r\n                            }}\r\n                            >\r\n                            Search\r\n                        </Button>\r\n                </form>\r\n            </Grid>\r\n            <Grid item xs={12}>\r\n                {isError && <Typography variant=\"h5\" color=\"error\">\r\n                    Error: {loadingError}\r\n                </Typography>}\r\n                {isLoading && <CircularProgress color=\"secondary\"></CircularProgress>}\r\n            </Grid>\r\n        </Grid>\r\n    );\r\n};\r\n\r\nexport default Loading;\r\n","import React from 'react';\nimport { useSelector } from 'react-redux';\nimport Forecast from './components/forecast';\nimport Loading from './components/loading';\nimport { getLoadingStatus } from './store/store';\n\n\nconst App = (props: {\n\n}) => {\n  const loadingStatus = useSelector(getLoadingStatus);\n  const isLoaded = loadingStatus === \"succeeded\";\n\n  return (\n    isLoaded ? <Forecast /> : <Loading />\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n// TODO https://material-ui.com/components/typography/#general \n/**\n * Be careful when using this approach. Make sure your bundler doesn't eager load\n *  all the font variations (100/300/400/500/700/900, italic/regular, SVG/woff). \n * Fontsource can be configured to load specific subsets, weights and styles. \n * Inlining all the font files can significantly increase the size of your bundle.\n *  Material-UI default typography configuration only relies on 300, 400, 500, \n * and 700 font weights.\n *  */ \nimport '@fontsource/roboto';\nimport { configureStore } from '@reduxjs/toolkit';\nimport { forecastSlice } from './store/store';\nimport { Provider } from 'react-redux';\n\nconst store = configureStore({\n  reducer: {\n      forecast: forecastSlice.reducer\n  }\n});\n\nReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}